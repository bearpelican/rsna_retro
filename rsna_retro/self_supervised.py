# AUTOGENERATED! DO NOT EDIT! File to edit: 08_train_self_supervised.ipynb (unless otherwise specified).

__all__ = ['get_ss_gen', 'get_ss_data', 'pipe_update_size', 'get_aug_pipe', 'SSModel', 'CombinedSSLoss', 'wrap_metric',
           'SSCallback']

# Cell
from .imports import *
from .metadata import *
from .preprocess import *
from .train import *
from .contrastive_loss import *

# Cell
def get_ss_gen(fns, bs, img_tfm, splits, nw=8, test=False):
    tfms = [[img_tfm, ToTensor], [fn2label,EncodedMultiCategorize(htypes)]]
    if test: tfms = [tfms[0]]
    dsets = Datasets(fns, tfms, splits=splits)
    batch_tfms = L(IntToFloatTensor)
    return dsets.dataloaders(bs=bs, num_workers=nw, after_batch=batch_tfms)

# Cell
def get_ss_data(bs, splits, img_dir=path_jpg256, **kwargs):
    return get_ss_gen(L(list(Meta.df_comb.index)), bs=bs, img_tfm=get_pil_fn(path/img_dir),
                      splits=splits, **kwargs)

# Cell
def pipe_update_size(pipe, size):
    for tf in pipe.fs:
        if isinstance(tf, RandomResizedCropGPU):
            tf.size = size

# Cell
def get_aug_pipe(size, min_scale=0.4, stats=(mean,std), **kwargs):
    tfms = [Normalize.from_stats(*stats)] + aug_transforms(size=size, min_scale=min_scale, **kwargs)
    return Pipeline(tfms)

# Cell
class SSModel(nn.Sequential):
    def __init__(self, model:nn.Sequential): super().__init__(*model)

    def features(self, x):
        return super().forward(x)
#         return self[1][:2](self[0](x))

    def logits(self, x):
        return x
#         return self[1][2:](x)

    def forward(self, *args):
        feats = [self.features(x) for x in args]
        logits = [self.logits(x) for x in feats]
        return tuple(feats), tuple(logits)

# Cell
class CombinedSSLoss(nn.Module):
    def __init__(self, ss_loss_func, orig_loss_func, multi_loss=False):
        super().__init__()
        store_attr(self, 'ss_loss_func,orig_loss_func,multi_loss')

    def ss_loss(self, preds, labels):
        (anchor, positive), _ = preds
        return self.ss_loss_func(anchor, positive)

    def orig_loss(self, preds, labels):
        _, (logits_targ, _) = preds
        return self.orig_loss_func(logits_targ, labels)

    def forward(self, preds, labels):
        if not self.multi_loss: return self.ss_loss(preds, labels)
        return self.ss_loss(preds, labels) + self.orig_loss(preds, labels)

# Cell
from functools import wraps
def wrap_metric(f):
    @wraps(f)
    def wrapped_f(preds, targ):
        _, (inp, _) = preds
        return f(inp, targ)
    return wrapped_f

# Cell
class SSCallback(Callback):
    run_before=Recorder
    def __init__(self, loss_func, size=256, aug_targ=None, aug_pos=None, multi_loss=False):
        self.aug_targ = ifnone(aug_targ, get_aug_pipe(size, min_scale=0.7))
        self.aug_pos = ifnone(aug_pos, get_aug_pipe(size, min_scale=0.4))
        self.ss_loss_func = loss_func
        self.multi_loss = multi_loss
        self.orig_metrics = None

    def update_size(self, size):
        pipe_update_size(self.aug_targ, size)
        pipe_update_size(self.aug_pos, size)

    def begin_fit(self):
        self.learn.model = SSModel(self.learn.model)


        lf = CombinedSSLoss(self.ss_loss_func, self.learn.loss_func, self.multi_loss)
        self.learn.loss_func = lf
        self.orig_metrics = self.learn.metrics

        self.learn.metrics = [wrap_metric(f.func) for f in self.orig_metrics]
        self.learn.dls.valid.shuffle = True # prevents high loss if images ordered by class
        if self.multi_loss:
            self.learn.metrics += [lf.ss_loss, lf.orig_loss]

    def after_fit(self):
        self.learn.model = nn.Sequential(*self.learn.model)
        self.learn.loss_func = self.learn.loss_func.orig_loss_func
        self.learn.metrics = self.orig_metrics
        self.learn.dls.valid.shuffle = False

    def set_split(self, split_idx):
        self.aug_targ.split_idx = split_idx
#         self.aug_pos.split_idx = split_idx # always keep augmentation
    def begin_validate(self): self.set_split(1)
    def begin_train(self): self.set_split(0)

    def begin_batch(self):
        xb, = self.learn.xb
        xb_targ = self.aug_targ(xb)
        xb_pos = self.aug_pos(xb)
        self.learn.xb = xb_targ, xb_pos
