# AUTOGENERATED! DO NOT EDIT! File to edit: 08_train_self_supervised.ipynb (unless otherwise specified).

__all__ = ['get_ss_gen', 'get_ss_data', 'pipe_update_size', 'get_aug_pipe', 'TripletLoss', 'SSModel', 'CombinedSSLoss',
           'accuracy_ss', 'SSCallback', 'SSTripletLoss', 'ContrastiveLoss', 'BatchContrastiveLoss']

# Cell
from .imports import *
from .metadata import *
from .preprocess import *
from .train import *

# Cell
def get_ss_gen(fns, bs, img_tfm, splits, nw=8, test=False):
    tfms = [[img_tfm, ToTensor], [fn2label,EncodedMultiCategorize(htypes)]]
    if test: tfms = [tfms[0]]
    dsets = Datasets(fns, tfms, splits=splits)
    batch_tfms = L(IntToFloatTensor)
    return dsets.dataloaders(bs=bs, num_workers=nw, after_batch=batch_tfms)

# Cell
def get_ss_data(bs, splits, img_dir=path_jpg256, **kwargs):
    return get_ss_gen(L(list(Meta.df_comb.index)), bs=bs, img_tfm=get_pil_fn(path/img_dir),
                      splits=splits, **kwargs)

# Cell
def pipe_update_size(pipe, size):
    for tf in pipe.fs:
        if isinstance(tf, RandomResizedCropGPU):
            tf.size = size

# Cell
def get_aug_pipe(size, min_scale=0.5, **kwargs):
    tfms = [Normalize.from_stats(mean,std)] + aug_transforms(size=size, min_scale=min_scale, **kwargs)
    return Pipeline(tfms)

# Cell
class TripletLoss(nn.Module):
    """
    Triplet loss
    Takes embeddings of an anchor sample, a positive sample and a negative sample
    """

    def __init__(self, margin=0.5):
        super(TripletLoss, self).__init__()
        self.margin = margin

    def forward(self, anchor, positive, negative, size_average=True):
        distance_positive = (anchor - positive).pow(2).sum(1)  # .pow(.5)
        distance_negative = (anchor - negative).pow(2).sum(1)  # .pow(.5)
        losses = F.relu(distance_positive - distance_negative + self.margin)
        return losses.mean() if size_average else losses.sum()


# Cell
class SSModel(nn.Sequential):
    def __init__(self, model:nn.Sequential): super().__init__(*model)

    def features(self, x):
        return self[1][:2](self[0](x))

    def logits(self, x):
        return self[1][2:](x)

    def forward(self, *args):
        feats = [self.features(x) for x in args]
        logits = [self.logits(x) for x in feats]
        return tuple(feats), tuple(logits)

# Cell
class CombinedSSLoss(nn.Module):
    def __init__(self, ss_loss_func, orig_loss_func):
        super().__init__()
        store_attr(self, 'ss_loss_func,orig_loss_func')

    def ss_loss(self, preds, labels): return self.ss_loss_func(preds, labels)
    def orig_loss(self, preds, labels):
        feats, (logits_targ, logits_pos) = preds
        return self.orig_loss_func(logits_targ, labels)

    def forward(self, preds, labels):
        return self.ss_loss(preds, labels) + self.orig_loss(preds, labels)

# Cell
def accuracy_ss(preds, targ, thresh=0.5, sigmoid=True):
    _, (inp, _) = preds
    return accuracy_any(inp, targ, thresh, sigmoid)

# Cell
class SSCallback(Callback):
    run_before=Recorder
    def __init__(self, loss_func, size=256, aug_targ=None, aug_pos=None, combined_loss=False):
        self.aug_targ = ifnone(aug_targ, get_aug_pipe(size, min_scale=0.7))
        self.aug_pos = ifnone(aug_pos, get_aug_pipe(size, min_scale=0.4))
        self.loss_func = loss_func
        self.combined_loss = combined_loss

        self.orig_loss_func = None
        self.orig_metrics = None

    def update_size(self, size):
        pipe_update_size(self.aug_targ, size)
        pipe_update_size(self.aug_pos, size)

    def begin_fit(self):
        self.learn.model = SSModel(self.learn.model)
        self.orig_loss_func = self.learn.loss_func
        self.learn.loss_func = CombinedSSLoss(self.loss_func, self.learn.loss_func) if self.combined_loss else self.loss_func

        if self.combined_loss:
            self.orig_metrics = self.learn.metrics
            c = self.learn.loss_func
            self.learn.metrics = self.orig_metrics + [accuracy_ss, c.ss_loss, c.orig_loss]

    def after_fit(self):
        self.learn.model = nn.Sequential(*self.learn.model)
        self.learn.loss_func = self.orig_loss_func
        self.learn.metrics = self.orig_metrics

    def set_split(self, split_idx):
        self.aug_targ.split_idx = split_idx
#         self.aug_pos.split_idx = split_idx # always keep augmentation
    def begin_validate(self): self.set_split(1)
    def begin_train(self): self.set_split(0)

    def begin_batch(self):
        xb, = self.learn.xb
        xb_targ = self.aug_targ(xb)
        xb_pos = self.aug_pos(xb)
        self.learn.xb = xb_targ, xb_pos


# Cell
class SSTripletLoss(TripletLoss):
    def forward(self, preds, labels, size_average=True):
        (anchor, positive), logits = preds
        negative = positive.flip(dims=[0])
        return super().forward(anchor, positive, negative, size_average)


# Cell
class ContrastiveLoss(nn.Module):
    """
    Contrastive loss
    Takes embeddings of two samples and a target label == 1 if samples are from the same class and label == 0 otherwise
    """
    def __init__(self, margin):
        super(ContrastiveLoss, self).__init__()
        self.margin = margin
        self.eps = 1e-9

    def forward(self, output1, output2, target, size_average=True):
        distances = (output2 - output1).pow(2).sum(1)  # squared distances
        losses = 0.5 * (target.float() * distances +
                        (1 + -1 * target).float() * F.relu(self.margin - (distances + self.eps).sqrt()).pow(2))
        return losses.mean() if size_average else losses.sum()

# Cell
class BatchContrastiveLoss(nn.Module):
    def __init__(self, margin=0.5):
        super().__init__()
        self.loss_func = ContrastiveLoss(margin)

    def forward(self, preds, labels):
        (anchor, positive), logits = preds

        bs = anchor.shape[0]
        losses = []
        for i in range(bs):
            labels = torch.zeros(bs, device=anchor.device)
            labels[i] = 1 # set current target as the only positive label
            losses.append(self.loss_func(anchor[i], positive, labels))
        return torch.stack(losses).mean()