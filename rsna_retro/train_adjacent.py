#AUTOGENERATED! DO NOT EDIT! File to edit: dev/05_train_adjacent.ipynb (unless otherwise specified).

__all__ = ['TfmSlice', 'get_adj_dsrc', 'mean_5c', 'std_5c', 'mean_adj', 'std_adj', 'get_data_gen']

#Cell
from .imports import *
from .metadata import *
from .preprocess import *
from .train import *
from .train3d import *

#Cell
class TfmSlice:
    def __init__(self, df, path, c3=False):
        self.fn = get_pil_fn(path)
        self.tt = ToTensor()
        self.df = df
        self.c3 = c3

    def get_adj(self, idx, x_mid, sid_mid):
        if idx < 0 or idx >= self.df.shape[0] \
        or  self.df.iloc[idx].SeriesInstanceUID != sid_mid:
            return torch.zeros_like(x_mid)
        adj_item = self.df.index[idx]
        return self.tt(self.fn(adj_item))

    def __call__(self, item):
        idx = self.df.index.get_loc(item)
        sid = self.df.loc[item].SeriesInstanceUID
        x = self.tt(self.fn(item))
        x_prev = self.get_adj(idx-1, x, sid)
        x_next = self.get_adj(idx+1, x, sid)
        x = x[:1] if self.c3 else x

        return TensorCTScan(torch.cat([x_prev[:1], x, x_next[:1]]))

#Cell
def get_adj_dsrc(df, path=path_jpg256, grps=Meta.grps, cv_idx=0, column='SeriesInstanceUID',
               pad_to=None, c3=False):
    df_series = df.sort_values(['SeriesInstanceUID', "ImagePositionPatient2"])
    tfm = TfmSlice(df_series, path, c3=c3)
    sops = df_series.index.unique()
    splits_series = split_data(df_series, 0, grps, 'SeriesInstanceUID')
    dsrc = DataSource(sops, [[tfm],[fn2label,EncodedMultiCategorize(htypes)]], splits=splits_series)
    return dsrc

#Cell
mean_5c = [mean[0], *mean, mean[0]]
std_5c = [std[0], *std, std[0]]

mean_adj = [mean[0]]*3
std_adj = [mean[0]]*3

#Cell
def get_data_gen(df, grps, bs, sz=None, nw=8, wgts=None, batch_xtra=None, after_item=None, with_aug=True, test=False,
                 c3=False, **kwargs):
#     tfms = [[img_tfm, ToTensor], [fn2label,EncodedMultiCategorize(htypes)]]
#     if test: tfms = [tfms[0]]
    stats = (mean_adj, std_adj) if c3 else (mean_5c, std_5c)
    dsrc = get_adj_dsrc(Meta.df_any, grps=grps, c3=c3)
    nrm = Normalize.from_stats(*stats)
    batch_tfms = L(IntToFloatTensor, nrm, Cuda()) + L(batch_xtra)
    if with_aug: batch_tfms += aug_transforms(**kwargs)
    if sz is not None:
        batch_tfms = batch_tfms+[RandomResizedCropGPU(sz, min_scale=0.7, ratio=(1.,1.), valid_scale=0.9)]
    if wgts is None:
        return dsrc.databunch(bs=bs, num_workers=nw, after_item=after_item, after_batch=batch_tfms)
    else:
        return dsrc.weighted_databunch(wgts, bs=bs, num_workers=nw, after_item=after_item, after_batch=batch_tfms)
