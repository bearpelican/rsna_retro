# AUTOGENERATED! DO NOT EDIT! File to edit: 03_train3d.ipynb (unless otherwise specified).

__all__ = ['OpenCTs', 'pad_batch', 'pad_collate', 'max_seq', 'TfmSOP', 'get_3d_dsets', 'get_dls', 'get_3d_dls', 'Tfm5D',
           'Tfm6D', 'PipeMeta', 'get_3d_dls_aug', 'get_3d_dls_album', 'Wrap', 'get_np_fn', 'get_3d_dls_feat',
           'ReshapeBodyHook', 'conv3', 'Batchify', 'DeBatchify', 'get_3d_head', 'DePadLoss']

# Cell
from .imports import *
from .metadata import *
from .preprocess import *
from .train import *

# Cell
class OpenCTs:
    def __init__(self, path, open_fn=get_pil_fn, tfms=None):
        self.fn = open_fn(path)
        if tfms is None: tfms = []
        self.tfms = Pipeline(tfms+[ToTensor])
    def __call__(self, item):
        if isinstance(item, (str, Path)): return self.tfms(self.fn(item))
        xs = [self.tfms(self.fn(x)) for x in item]
        return TensorCTScan(torch.stack(xs))

# Cell
max_seq = 60
def pad_batch(x, pad_to=None, value=0):
    if isinstance(x, tuple): return tuple([pad_batch(s, pad_to, value) for s in x])
    if isinstance(x, dict): return {k:pad_batch(item, pad_to, value) for k,item in x.items()}
    bs_pad = pad_to-x.shape[0]
    pad = [0]*len(x.shape)*2
    pad[-1] = bs_pad
    return type(x)(F.pad(x, pad=pad, value=value))

# def pad_collate(items, values=[0,-1], pad_to=max_seq):
def pad_collate(items, values=[0,-1], pad_to=max_seq):
#     def get_bs(x): return x[0].shape[0] if hasattr(x[0], 'shape') else get_bs(x[0])
#     pad_to = max([get_bs(x) for x in items]) if fixed_pad is None else fixed_pad
    pad_to = 60
    def pad_row(row, pad_to, vals): return tuple([pad_batch(x,pad_to,v) for x,v in zip(row,vals)])
    res = [pad_row(row, pad_to, values) for row in items]
    return res

# Cell
# saving hardcoded positioning so we can normalize the test set the same way
pos_min, pos_max, pos_mean, pos_std = (-998.400024, 1794.01276, 167.08153131830622, 244.90964319136026)

# Cell
class TfmSOP:
    def __init__(self,df,open_fn,test=False,meta=False):
        store_attr(self, 'df,open_fn,test,meta')

    def x(self, sid):
        sids = self.df.SOPInstanceUID[sid].values
        imgs = self.open_fn(sids)
        if self.meta:
            pos = self.df.ImagePositionPatient2[sid].values.reshape(-1, 1)
            pos = torch.from_numpy(pos).float()
            pos_norm = (pos - pos_mean)/pos_std
#             return {'ct':imgs, 'pos':pos_norm}
            return imgs, pos_norm
        return imgs

    def y(self, sid):
        sids = self.df.SOPInstanceUID[sid].values
        if self.test: return torch.zeros((self.df.loc[sid].shape[0], 6)).float()
        vals = self.df.loc[sid,htypes].values
        return TensorMultiCategory(tensor(vals)).float()

# Cell
def get_3d_dsets(df, open_fn, grps=Meta.grps_stg1, cv_idx=0, tfms=None, column='SeriesInstanceUID', test=False, meta=False):
    df_series = df.reset_index().set_index(column).sort_values([column, "ImagePositionPatient2"])
    sids = df_series.index.unique()
    sid2idx = dict(zip(sids, range(len(sids))))

    # multi index is 10x faster
    df_series.index = pd.MultiIndex.from_tuples(df_series.index.str.split('|').tolist())
    tfm = TfmSOP(df_series, open_fn, test=test, meta=meta)

    if test:
        splits=[L.range(sids), L.range(sids)]
    else:
        s1 = [sid2idx[sid] for sid in group_cv(cv_idx,grps) if sid in sid2idx]
        s2 = [sid2idx[sid] for sid in grps[cv_idx] if sid in sid2idx]
        splits = (s1, s2)
    dsets = Datasets(sids, [[tfm.x]+L(tfms),[tfm.y]], splits=splits)
    return dsets

# Cell
def get_dls(dsets, bs, batch_tfms, num_workers=8):
    before_batch = [pad_collate] if bs != 1 else []
    dls = DataLoaders(
        TfmdDL(dsets.train, bs=bs, before_batch=before_batch, after_batch=batch_tfms, num_workers=num_workers, shuffle=True),
        TfmdDL(dsets.valid, bs=bs, before_batch=before_batch, after_batch=batch_tfms, num_workers=num_workers)
    )
    dls.device = default_device()
    dls.c = 6
    return dls

# Cell
def get_3d_dls(df, path=path_jpg256, bs=1, num_workers=8, tfms=None, **kwargs):
    dsets = get_3d_dsets(df, open_fn=OpenCTs(path), **kwargs)

    nrm = Normalize.from_stats(mean,std)
    batch_tfms = L(IntToFloatTensor(), nrm, *L(tfms))

    return get_dls(dsets, bs, batch_tfms, num_workers)


# Cell
class Tfm5D(Transform):
    order = 0
    def encodes(self, o:TensorImage): return o.view(-1, *o.shape[-3:])
class Tfm6D(Transform):
    order = 200
    def encodes(self, o:TensorImage): return o.view(-1, max_seq, *o.shape[-3:])

# Cell
class PipeMeta(Pipeline):
    def __call__(self, o):
#         if isinstance(o, tuple): return [super(PipeMeta, self).__call__(x) for x in o]
        if isinstance(o, tuple):
            return super().__call__(TensorCTScan(o[0])), o[1]
        return super().__call__(o)

# Cell
def get_3d_dls_aug(df, sz=None, path=path_jpg256, bs=1, num_workers=8, grps=Meta.grps_stg1, test=False, meta=False):
    dsets = get_3d_dsets(df, open_fn=OpenCTs(path), grps=grps, test=test, meta=meta)

    tfms = [Tfm5D(), IntToFloatTensor(), Tfm6D()]+aug_transforms()
    if sz is not None: tfms = tfms+[RandomResizedCropGPU(sz, min_scale=0.7, ratio=(1.,1.), valid_scale=0.9)]

    nrm = Normalize.from_stats(mean,std)
    batch_tfms = tfms+L(nrm)

    if meta: return get_dls(dsets, bs, [PipeMeta(batch_tfms)], num_workers)
    return get_dls(dsets, bs, batch_tfms, num_workers)


# Cell
def get_3d_dls_album(df, sz=None, path=path_jpg256, bs=1, num_workers=8, grps=Meta.grps_stg1, test=False, meta=False):

    nrm = Normalize.from_stats(mean,std,cuda=False,dim=0,ndim=3)
    ab_tfms = [ABTfms((sz,sz)), image2tensor, IntToFloatTensor(), nrm]
    dsets = get_3d_dsets(df, open_fn=OpenCTs(path, get_cv2_fn, tfms=ab_tfms), grps=grps, test=test, meta=meta)
#     batch_tfms = [nrm]
    batch_tfms=None
    if meta: return get_dls(dsets, bs, batch_tfms, num_workers)
    return get_dls(dsets, bs, batch_tfms, num_workers)


# Cell
class Wrap():
    def __init__(self, tfm, tfm_all=True): self.tfm = tfm
    def __getattr__(self, x): return getattr(self.tfm, x)
    def __call__(self, *args, **kwargs): return self.encodes(*args, **kwargs)
    def encodes(self, x:TensorImage): return self.reshape(x, self.tfm)
    def decodes(self, x:TensorImage): return self.reshape(x, self.tfm.decodes)

    def reshape(self, x, func):
        if len(x.shape) != 5: return x
        bs,ts,ch,w,h = x.shape
        x = x.reshape(-1,ch,w,h)
        out = func(x)
        return out.reshape(bs,ts, *out.shape[-3:])


# wrapped_tfms = [Wrap(tfm) for tfm in aug_transforms()]

# Cell
def get_np_fn(p):
    def _f(fn): return torch.from_numpy(np.load(str(p/f'{fn}.npy')))
    return _f

# Cell
def get_3d_dls_feat(df, path=path_feat_384avg, bs=1, num_workers=8, test=False, meta=False):
    dsets = get_3d_dsets(df, open_fn=OpenCTs(path, get_np_fn), test=test, meta=meta)
    return get_dls(dsets, bs, [], num_workers)


# Cell
class ReshapeBodyHook():
    def __init__(self, body):
        super().__init__()
        self.pre_reg = body.register_forward_pre_hook(self.pre_hook)
        self.reg = body.register_forward_hook(self.forward_hook)
        self.shape = None

    def deregister(self):
        self.reg.remove()
        self.pre_reg.remove()

    def pre_hook(self, module, input):
        x = input[0]
        self.shape = x.shape
        return (x.view(-1, *x.shape[2:]),)

    def forward_hook(self, module, input, x):
        return x.view(*self.shape[:2], *x.shape[1:])

# Cell
def conv3(ni,nf,stride=1):
    return ConvLayer(ni, nf, (5,3,3), stride=(1,stride,stride), ndim=3, padding=(2,1,1))

# Cell
class Batchify(Module):
    def forward(self, x): return x.transpose(1,2)

class DeBatchify(Module):
    def forward(self, x):
        x_t = x.transpose(1,2)
        x_c = x_t.contiguous().view(-1, *x_t.shape[2:])
        return x_c

def get_3d_head(concat_pool=True):
    pool, feat = (AdaptiveConcatPool2d(1), 64*2) if concat_pool else (nn.AdaptiveAvgPool2d(1), 64)
    m = nn.Sequential(Batchify(),
        conv3(512,256,2), # 8
        conv3(256,128,2), # 4
        conv3(128, 64,2), # 2
        DeBatchify(), pool, Flatten(), nn.Linear(feat,6))
    init_cnn(m)
    return m

# Cell
class DePadLoss(Callback):
    def __init__(self, pad_idx=-1):
        super().__init__()
        store_attr(self, 'pad_idx')

    def after_pred(self):
        learn = self.learn
        targ = learn.yb[0].view(-1, *learn.yb[0].shape[2:])
        if targ.shape[0] != self.pred.shape[0]:
            pred = learn.pred.view(-1, *learn.pred.shape[2:])
        else: pred = learn.pred

        mask = targ[:,-1] != self.pad_idx

        learn.pred = pred[mask]
        learn.yb = (targ[mask],)