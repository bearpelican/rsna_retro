#AUTOGENERATED! DO NOT EDIT! File to edit: dev/02_train_01_train.ipynb (unless otherwise specified).

__all__ = ['get_pil_fn', 'fn2label', 'get_data_gen', 'mean', 'std', 'get_learner', 'do_fit', 'submission']

#Cell
from .imports import *
from .metadata import *
from .preprocess import *

#Cell
def get_pil_fn(p):
    def _f(fn):
        img_id = df_comb.loc[fn].SOPInstanceUID
        return PILCTScan.create(p/f'{img_id}.jpg')
    return _f

#Cell
def fn2label(fn): return df_comb.loc[fn][htypes].values.astype(np.float32)

#Cell
def get_data_gen(fns, bs, img_tfm, mean, std, splits, sz=None, nw=8,
        wgts=None, batch_xtra=None, after_item=None, with_aug=True, **kwargs):
    tfms = [[img_tfm, ToTensor], [fn2label,EncodedMultiCategorize(htypes)]]
    dsrc = DataSource(fns, tfms, splits=splits)
    nrm = Normalize.from_stats(mean,std)
    batch_tfms = L(IntToFloatTensor, nrm, Cuda()) + L(batch_xtra)
    if with_aug: batch_tfms += aug_transforms(**kwargs)
    if sz is not None:
        batch_tfms = batch_tfms+[RandomResizedCropGPU(sz, min_scale=0.7, ratio=(1.,1.), valid_scale=0.9)]
    if wgts is None:
        return dsrc.databunch(bs=bs, num_workers=nw, after_item=after_item, after_batch=batch_tfms)
    else:
        return dsrc.weighted_databunch(wgts, bs=bs, num_workers=nw, after_item=after_item, after_batch=batch_tfms)


#Cell
mean = [ 56.2214,  62.1220, 141.9133]
std = [93.0132, 77.8876, 50.8730]

#Cell
def get_learner(dbch, arch, lf, pretrained=True, opt_func=None, metrics=None, fp16=True, config=None):
    if metrics is None: metrics=[accuracy_multi,accuracy_any]
    if opt_func is None: opt_func = partial(Adam, wd=1e-5, eps=1e-4, sqr_mom=0.999)
    if config is None: config=dict(ps=0., lin_ftrs=[], concat_pool=False)
    learn = cnn_learner(dbch, arch, pretrained=pretrained, loss_func=lf, lr=3e-3,
                        opt_func=opt_func, metrics=metrics, config=config)
    return learn.to_fp16() if fp16 else learn

#Cell
def do_fit(learn, epochs, lr, freeze=True, do_slice=False, **kwargs):
    if do_slice: lr = slice(lr*3,lr)
    if freeze:
        learn.freeze()
        learn.fit_one_cycle(1, lr, div=2, div_final=1, pct_start=0.1)
    learn.unfreeze()
    learn.fit_one_cycle(epochs, lr, **kwargs)

#Cell
def submission(df_tst, preds, fn='submission'):
    ids,labels = [],[]
    for idx,pred in zip(df_tst.index, preds):
        for i,label in enumerate(htypes):
            ids.append(f"{idx}_{label}")
            labels.append('{0:1.10f}'.format(pred[i].item()))
    df_csv = pd.DataFrame({'ID': ids, 'Label': labels})
    df_csv.to_csv(f'{fn}.csv', index=False)
    return df_csv